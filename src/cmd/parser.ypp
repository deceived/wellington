%{

#include "order.hpp"

%}

%debug

%defines

%skeleton "lalr1.cc"

%name-prefix "order"

%define "parser_class_name" { Parser }

%locations

%parse-param { class Driver& driver }

%error-verbose

%union {
	int	integerVal;
	std::string* stringVal;
	class Order* order;
}

%token				MOVE	  "move"
%token				TO		  "to"
%token				THE		  "the"
 
%token  			END		0 "end of file"
%token				EOL		  "end of line"
%token <integerVal> INTEGER   "integer"
%token <stringVal>  STRING    "string"

%type <Order>		move_order

%token  	MOVE
%token      TO
%token      THE
%token      N
%token      S
%token      E
%token      W
%token      NW
%token      NE
%token      SW
%token      SE
%token		PERIOD '.'

%{

#include "driver.hpp"
#include "scanner.hpp"

#undef yylex
#define yylex driver.lexer_->lex

%}

%%

start				:	
					|	start '.'
					|	start EOL
					|	start order '.'
					|	start order EOL
					|	start order END
					;
					
order				:	move_order
					;
 
move_order             :   MOVE TO THE compass_direction PERIOD
                    ;

compass_direction   :   N
                    |   S
                    |   E
                    |   W
                    |   NW
                    |   NE
                    |   SW
                    |   SE
                    ;

%%

void order::Parser::error(  const Parser::location_type& l,
							const std::string& m )
{
	driver.Error( l, m );
}

