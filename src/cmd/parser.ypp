%{

#include "order.hpp"

%}

%debug

%defines

%skeleton "lalr1.cc"

%name-prefix "order"

%define "parser_class_name" { Parser }

%locations

%parse-param { class Driver& driver }

%error-verbose

%union {
	int	integerVal;
	std::string* stringVal;
	class Order* order;
}

%token  			END		0 "end of file"
%token				EOL		  "end of line"
%token <integerVal> INTEGER   "integer"
%token <stringVal>  STRING    "string"

%type <order>		move_order order
%type <stringVal>	compass_direction N S E W NW NE SW SE

%token  	MOVE
%token      TO
%token      THE
%token      N
%token      S
%token      E
%token      W
%token      NW
%token      NE
%token      SW
%token      SE
%token		PERIOD '.'

%{

#include "driver.hpp"
#include "scanner.hpp"

#undef yylex
#define yylex driver.lexer_->lex

%}

%%

start				:	
					|	start '.'
					|	start EOL
					|	start order '.'
						{
							driver.orders_.orders_.push_back( $2 );
						}
					|	start order EOL
						{
							driver.orders_.orders_.push_back( $2 );
						}
					|	start order END
						{
							driver.orders_.orders_.push_back( $2 );
						}
					;
					
order				:	move_order
						{
							$$ = $1;
						}
					;
 
move_order          :   MOVE TO THE compass_direction PERIOD
						{
							$$ = new MoveOrder( *$4 );
						}
                    ;

compass_direction   :   N
                    |   S
                    |   E
                    |   W
                    |   NW
                    |   NE
                    |   SW
                    |   SE
                    ;

%%

void order::Parser::error(  const Parser::location_type& l,
							const std::string& m )
{
	driver.Error( l, m );
}

